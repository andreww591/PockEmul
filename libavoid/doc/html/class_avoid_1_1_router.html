<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avoid::Router Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<style>
pre { 
    border: dotted 1px #900; 
    padding: 5px; 
    background-color: #ffe;
}
a.anchor:hover {
    text-decoration: none;
}
</style>
</head>
<body>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_avoid.html">Avoid</a></li><li class="navelem"><a class="el" href="class_avoid_1_1_router.html">Router</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_avoid_1_1_router-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Avoid::Router Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> class represents a libavoid router instance.  
 <a href="class_avoid_1_1_router.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="router_8h_source.html">router.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae0b300221fbff0d5539ef42e99d8714"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aae0b300221fbff0d5539ef42e99d8714">Router</a> (const unsigned int flags)</td></tr>
<tr class="memdesc:aae0b300221fbff0d5539ef42e99d8714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for router instance.  <a href="#aae0b300221fbff0d5539ef42e99d8714">More...</a><br/></td></tr>
<tr class="separator:aae0b300221fbff0d5539ef42e99d8714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415aa6409ec5d573bcdb90b1ce73e020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a415aa6409ec5d573bcdb90b1ce73e020">~Router</a> ()</td></tr>
<tr class="memdesc:a415aa6409ec5d573bcdb90b1ce73e020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for router instance.  <a href="#a415aa6409ec5d573bcdb90b1ce73e020">More...</a><br/></td></tr>
<tr class="separator:a415aa6409ec5d573bcdb90b1ce73e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2908173631381499be763ea0b0dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad">setTransactionUse</a> (const bool transactions)</td></tr>
<tr class="memdesc:a74b2908173631381499be763ea0b0dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting of the behaviour of the router in regard to transactions. This controls whether transactions are used to queue changes and process them effeciently at once or they are instead processed immediately.  <a href="#a74b2908173631381499be763ea0b0dad">More...</a><br/></td></tr>
<tr class="separator:a74b2908173631381499be763ea0b0dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa322ef199e508ea8a7b74a29b4ab846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aaa322ef199e508ea8a7b74a29b4ab846">transactionUse</a> (void) const </td></tr>
<tr class="memdesc:aaa322ef199e508ea8a7b74a29b4ab846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the router groups actions into transactions.  <a href="#aaa322ef199e508ea8a7b74a29b4ab846">More...</a><br/></td></tr>
<tr class="separator:aaa322ef199e508ea8a7b74a29b4ab846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4497126d8d4c76a122af565260941fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc">processTransaction</a> (void)</td></tr>
<tr class="memdesc:ac4497126d8d4c76a122af565260941fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the current transaction and processes all the queued object changes efficiently.  <a href="#ac4497126d8d4c76a122af565260941fc">More...</a><br/></td></tr>
<tr class="separator:ac4497126d8d4c76a122af565260941fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59a24d798300c35f8dc3e5fb10840d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a7b59a24d798300c35f8dc3e5fb10840d">addShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape)</td></tr>
<tr class="memdesc:a7b59a24d798300c35f8dc3e5fb10840d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a shape to the router scene.  <a href="#a7b59a24d798300c35f8dc3e5fb10840d">More...</a><br/></td></tr>
<tr class="separator:a7b59a24d798300c35f8dc3e5fb10840d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c819a2f613feba4ed142baca1b283b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a13c819a2f613feba4ed142baca1b283b">removeShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape)</td></tr>
<tr class="memdesc:a13c819a2f613feba4ed142baca1b283b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a shape from the router scene.  <a href="#a13c819a2f613feba4ed142baca1b283b">More...</a><br/></td></tr>
<tr class="separator:a13c819a2f613feba4ed142baca1b283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766c0dd498c38822cf9ea7c77af28b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a766c0dd498c38822cf9ea7c77af28b3d">moveShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape, const <a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;newPoly, const bool first_move=false)</td></tr>
<tr class="memdesc:a766c0dd498c38822cf9ea7c77af28b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move or resize an existing shape within the router scene.  <a href="#a766c0dd498c38822cf9ea7c77af28b3d">More...</a><br/></td></tr>
<tr class="separator:a766c0dd498c38822cf9ea7c77af28b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac171735c187b3e0ea8f03fda4424fd4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ac171735c187b3e0ea8f03fda4424fd4f">moveShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape, const double xDiff, const double yDiff)</td></tr>
<tr class="memdesc:ac171735c187b3e0ea8f03fda4424fd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing shape within the router scene by a relative distance.  <a href="#ac171735c187b3e0ea8f03fda4424fd4f">More...</a><br/></td></tr>
<tr class="separator:ac171735c187b3e0ea8f03fda4424fd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3f89cb20f82cf3faf3b7b53aca6c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a2d3f89cb20f82cf3faf3b7b53aca6c3d">addJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction)</td></tr>
<tr class="memdesc:a2d3f89cb20f82cf3faf3b7b53aca6c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a junction from the router scene.  <a href="#a2d3f89cb20f82cf3faf3b7b53aca6c3d">More...</a><br/></td></tr>
<tr class="separator:a2d3f89cb20f82cf3faf3b7b53aca6c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99dd5c020c208ab16b4699ef2085f4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aa99dd5c020c208ab16b4699ef2085f4e">removeJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction)</td></tr>
<tr class="memdesc:aa99dd5c020c208ab16b4699ef2085f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a junction from the router scene.  <a href="#aa99dd5c020c208ab16b4699ef2085f4e">More...</a><br/></td></tr>
<tr class="separator:aa99dd5c020c208ab16b4699ef2085f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08021cac275575c7795e2005e5eadb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a08021cac275575c7795e2005e5eadb9a">moveJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction, const <a class="el" href="class_avoid_1_1_point.html">Point</a> &amp;newPosition)</td></tr>
<tr class="memdesc:a08021cac275575c7795e2005e5eadb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing junction within the router scene.  <a href="#a08021cac275575c7795e2005e5eadb9a">More...</a><br/></td></tr>
<tr class="separator:a08021cac275575c7795e2005e5eadb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e5639b590902b5e734a1068fdc663c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a94e5639b590902b5e734a1068fdc663c">moveJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction, const double xDiff, const double yDiff)</td></tr>
<tr class="memdesc:a94e5639b590902b5e734a1068fdc663c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing junction within the router scene by a relative distance.  <a href="#a94e5639b590902b5e734a1068fdc663c">More...</a><br/></td></tr>
<tr class="separator:a94e5639b590902b5e734a1068fdc663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668772cf99bc1b7c3d0f1ed612c8a6d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a668772cf99bc1b7c3d0f1ed612c8a6d2">setOrthogonalNudgeDistance</a> (const double dist)</td></tr>
<tr class="memdesc:a668772cf99bc1b7c3d0f1ed612c8a6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a spacing distance for overlapping orthogonal connectors to be nudged apart.  <a href="#a668772cf99bc1b7c3d0f1ed612c8a6d2">More...</a><br/></td></tr>
<tr class="separator:a668772cf99bc1b7c3d0f1ed612c8a6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e5770352ff7f37861c68d02bf790ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ae6e5770352ff7f37861c68d02bf790ec">orthogonalNudgeDistance</a> (void) const </td></tr>
<tr class="memdesc:ae6e5770352ff7f37861c68d02bf790ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the spacing distance that overlapping orthogonal connecotrs are nudged apart.  <a href="#ae6e5770352ff7f37861c68d02bf790ec">More...</a><br/></td></tr>
<tr class="separator:ae6e5770352ff7f37861c68d02bf790ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650314508371c0f0f049c760996826b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a650314508371c0f0f049c760996826b1">setRoutingPenalty</a> (const <a class="el" href="namespace_avoid.html#a987c87fd854204aaa7ba648232acc265">PenaltyType</a> penType, const double penVal=chooseSensiblePenalty)</td></tr>
<tr class="memdesc:a650314508371c0f0f049c760996826b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or removes penalty values that are applied during connector routing.  <a href="#a650314508371c0f0f049c760996826b1">More...</a><br/></td></tr>
<tr class="separator:a650314508371c0f0f049c760996826b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc7acd847e16a8f29e5960379ae6ac1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a3bc7acd847e16a8f29e5960379ae6ac1">routingPenalty</a> (const <a class="el" href="namespace_avoid.html#a987c87fd854204aaa7ba648232acc265">PenaltyType</a> penType) const </td></tr>
<tr class="memdesc:a3bc7acd847e16a8f29e5960379ae6ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current penalty value for a particular routing penalty case.  <a href="#a3bc7acd847e16a8f29e5960379ae6ac1">More...</a><br/></td></tr>
<tr class="separator:a3bc7acd847e16a8f29e5960379ae6ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> class represents a libavoid router instance. </p>
<p>Usually you would keep a separate <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> instance for each diagram or layout you have open in your application. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aae0b300221fbff0d5539ef42e99d8714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::Router::Router </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for router instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>One or more <a class="el" href="namespace_avoid.html#a8b398574e5b64951b7f23a36a1cdfcf4" title="Flags that can be passed to the router during initialisation to specify options.">Avoid::RouterFlag</a> options to control the behaviour of the router. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a415aa6409ec5d573bcdb90b1ce73e020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::Router::~Router </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for router instance. </p>
<dl class="section note"><dt>Note</dt><dd>Destroying a router instance will delete all remaining shapes and connectors, thereby invalidating any existing pointers to them. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2d3f89cb20f82cf3faf3b7b53aca6c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::addJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a junction from the router scene. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b59a24d798300c35f8dc3e5fb10840d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::addShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a shape to the router scene. </p>
<p>This shape will be considered to be an obstacle. Calling this method will cause connectors intersecting the added shape to be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08021cac275575c7795e2005e5eadb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>newPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing junction within the router scene. </p>
<p>Connectors that are attached to this junction will be rerouted as a result of the move.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPosition</td><td>The new position for the junction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94e5639b590902b5e734a1068fdc663c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>yDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing junction within the router scene by a relative distance. </p>
<p>Connectors that are attached to this junction will be rerouted as a result of the move.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDiff</td><td>The distance to move the junction in the x dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yDiff</td><td>The distance to move the junction in the y dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a766c0dd498c38822cf9ea7c77af28b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>first_move</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move or resize an existing shape within the router scene. </p>
<p>A new polygon for the shape can be given to effectively move or resize the shape with the scene. Connectors that intersect the new shape polygon, or that could have a better (usually shorter) path after the change, will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being moved/resized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPoly</td><td>The new polygon boundary for the shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_move</td><td>This option is used for some advanced (currently undocumented) behaviour and it should be ignored for the moment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac171735c187b3e0ea8f03fda4424fd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>yDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing shape within the router scene by a relative distance. </p>
<p>Connectors that intersect the shape's new position, or that could have a better (usually shorter) path after the change, will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDiff</td><td>The distance to move the shape in the x dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yDiff</td><td>The distance to move the shape in the y dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6e5770352ff7f37861c68d02bf790ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Avoid::Router::orthogonalNudgeDistance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the spacing distance that overlapping orthogonal connecotrs are nudged apart. </p>
<dl class="section return"><dt>Returns</dt><dd>The current spacing distance used for orthogonal nudging. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4497126d8d4c76a122af565260941fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::processTransaction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes the current transaction and processes all the queued object changes efficiently. </p>
<p>This method will efficiently process all moves, additions and deletions that have occurred since <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> was last called.</p>
<p>If <a class="el" href="class_avoid_1_1_router.html#aaa322ef199e508ea8a7b74a29b4ab846" title="Reports whether the router groups actions into transactions.">transactionUse()</a> is false, then all actions will have been processed immediately and this method will do nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value describing whether there were any actions to process.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">setTransactionUse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa99dd5c020c208ab16b4699ef2085f4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::removeJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a junction from the router scene. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13c819a2f613feba4ed142baca1b283b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::removeShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a shape from the router scene. </p>
<p>Connectors that could have a better (usually shorter) path after the removal of this shape will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bc7acd847e16a8f29e5960379ae6ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Avoid::Router::routingPenalty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a987c87fd854204aaa7ba648232acc265">PenaltyType</a>&#160;</td>
          <td class="paramname"><em>penType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current penalty value for a particular routing penalty case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">penType</td><td>The type of penalty, a PenaltyType. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The penalty value for the specified penalty case. </dd></dl>

</div>
</div>
<a class="anchor" id="a668772cf99bc1b7c3d0f1ed612c8a6d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setOrthogonalNudgeDistance </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a spacing distance for overlapping orthogonal connectors to be nudged apart. </p>
<p>By default, this distance is set to a value of 4.</p>
<p>This method does not re-trigger post-processing of connectors. The new distance will be used the next time rerouting is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist</td><td>The distance to be used for orthogonal nudging. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a650314508371c0f0f049c760996826b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setRoutingPenalty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a987c87fd854204aaa7ba648232acc265">PenaltyType</a>&#160;</td>
          <td class="paramname"><em>penType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>penVal</em> = <code>chooseSensiblePenalty</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or removes penalty values that are applied during connector routing. </p>
<p>By default, libavoid will produce shortest path routes between the source and destination points for each connector. There are several penalties that can be applied during this stage to improve the aesthetics of the routes generated. These different penalties are specified and explained by the PenaltyType enum.</p>
<p>If a value of zero or Avoid::noPenalty is given then the penalty for this case will be removed. If no penalty argument (or a negative value) is specified when calling this method, then a sensible penalty value will be automatically chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">penType</td><td>The type of penalty, a PenaltyType. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">penVal</td><td>The value to be applied for each occurance of the penalty case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74b2908173631381499be763ea0b0dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setTransactionUse </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transactions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows setting of the behaviour of the router in regard to transactions. This controls whether transactions are used to queue changes and process them effeciently at once or they are instead processed immediately. </p>
<p>It is more efficient to perform actions like shape movement, addition or deletion as batch tasks, and reroute the necessary connectors just once after these actions have been performed. For this reason, libavoid allows you to group such actions into "transactions" that are processed efficiently when the <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> method is called.</p>
<p>By default, the router will process all actions as tranactions. If <a class="el" href="class_avoid_1_1_router.html#aaa322ef199e508ea8a7b74a29b4ab846" title="Reports whether the router groups actions into transactions.">transactionUse()</a> is set to false, then all actions will get processed immediately, and cause immediate routing callbacks to all affected connectors after each action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transactions</td><td>A boolean value specifying whether to use transactions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa322ef199e508ea8a7b74a29b4ab846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::transactionUse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the router groups actions into transactions. </p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value describing whether transactions are in use.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">setTransactionUse</a> </dd>
<dd>
<a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="router_8h_source.html">router.h</a></li>
<li>router.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 6 2013 01:24:22 for libavoid by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
